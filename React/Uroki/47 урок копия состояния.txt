идемпотентность и детерминированность
Идемпотентность !== Детерминированность.

1) Идемпотентность - Свойство которое гарантирует, что при многократном вызове функции состояние будет изменено только единожды.
 Для примера можно посмотреть на работу DELETE в SQL.
 DELETE это идемпотентная операция. Например если в базе данных удалить с помощью DELETE ну к примеру пользователя, 
то при повторной попытке запуска такой функции с той же сигнатурой мы получаем что то вроде "This user already deleted".
 То есть мы 10 раз делаем попытку удаления пользователя, но состояние базы а именно ее изменение происходит единожды,
 остальные вызовы просто логируют, что операция уже была проведена, но ничего в самой базе не делают.

2) Детерминированность - Обрабатываем только то что получили в сигнатуре (аргументы).
  При многократном вызове такой функции с теми же параметрами мы получаем один и тот же результат как и должно быть,
 но мы не защищены от многократного изменения состояния. К примеру если мы попробуем добавить в нашу базу данных пользователя
 и никак не защитимся от дубликатов, то при вызове такой детерминированной функции 10 раз,
 мы получим 10 дубликатов пользователя в базе.



Итог: Детерминированность НЕ обеспечивает идемпотентность и на оборот.
 Идемпотентность НЕ обеспечивает детерминированность.
 Мы вполне свободно можем писать грязные функции с любым из этих свойств, и комбинировать их между собой.
 Это два разных и нечем не связанных свойства функций которые предлагают разные гарантии при реализации. 



Если я правильно догадался, то ...

У тебя есть исходный state (который хранится в redux: назовем его redux.state) и state - который возвращает твой reducer, назовем его reducer.state. Функция connect проверяет изменился ли redux.state после того, как прошел через reducer... и выясняет, что изменений нет. Почему? Потому что в reducer на вход передается ссылка на redux.state и когда ты меняешь state внутри reducer'a (reducer.state), то на самом деле - ты меняешь все тот же redux.state по ссылке. В итоге, все измменения, внесенные в reducer.state изменяют и redux.state (потому что они ссылаются на один и тот же объект в памяти, см.предидущее видео). И конечно же в результате проверки connect видит, что redux.state и reducer.state - совпадают, а значит ничего не поменялось.

А вот если сделать грамотную копию входящего state, то reducer.state будет работать с отдельным объктом в памяти, изменения которого не затронут redux.state. И при сравнении redux.state и reducer.state - функция connect выяснит, что есть расхождения и надо обнвлять VIRTUAL-DOM -> DOM.

P.S. Я уверен, что там реализована более умная проврка, чем просто redux.state === reducer.state, иначе просто правильная копия (без каких-либо изменений) выдавала бы false.





Смотри когда я чтото пишу в текст ареа(а его значение лежит в state) я через методы пропсы и тд попадаю в reducer, там я меняю редакс после попадаю в connect который сравнивает return из редюсера и наш редакс
тк мы меняем редакс внутри редюсера то получается они одинаковые и перерисовывать ничего не нужно
а должны мы были делать копию стэйта и коннект бы сравнивал return редюсера и редакса находил что есть изменения и перерисовывал все и перезаписал редакс